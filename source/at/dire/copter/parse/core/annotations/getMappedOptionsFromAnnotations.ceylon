import at.dire.copter.parse.core {
	MappedOptions,
	MappedAttribute,
	OrderedOperand,
	MappedGroup
}
import at.dire.copter.parse.core.parsers {
	ValueParserProvider
}
import at.dire.copter.parse.core.util {
	getAttributesAndConstructorParams,
	toOptionName
}
import at.dire.copter.read.collect {
	AvailableOption
}

import ceylon.collection {
	ArrayList
}
import ceylon.language.meta.model {
	Class
}

"Creates [[at.dire.copter.parse.core::MappedOptions]] based on various annotations."
see(`function option`, `function flag`, `function optionGroup`)
shared MappedOptions<Result,SpecialOption> getMappedOptionsFromAnnotations<out Result = Object, out SpecialOption = Nothing>(
	"The class we'll read members of."
	Class<Result> forClass,
	"Gives access to [[at.dire.copter.parse.core::ValueParser]]. May be reused."
	ValueParserProvider parserProvider = ValueParserProvider([`module`]),
	"Optional map of additional options."
	Map<String,SpecialOption> specialOptions = emptyMap) given Result satisfies Object given SpecialOption satisfies Object {

	// Add all special options directly to a list. There  we'll use for options later.
	value allOptionsList = ArrayList<AvailableOption<MappedAttribute|SpecialOption>> {
		initialCapacity = specialOptions.size;
	 	elements = { for(value specialOptionEntry in specialOptions) AvailableOption<SpecialOption> { key = specialOptionEntry.item; names = [specialOptionEntry.key]; abortAfter = true; readValue = false; } };
	};
	value allFields = ArrayList<MappedAttribute>();
	value allOperandsList = ArrayList<OrderedOperand>(1);
	value allOptionGroups = ArrayList<MappedGroup>(0);

	// Read all of the annotated attributes of this type as long as it is either an Option, Flag or Operand.
	for([attributeDeclaration,attributeType] in getAttributesAndConstructorParams<OptionAnnotation|OperandAnnotation|OptionGroupAnnotation>(forClass)) {
		// Check if this is an option group
		if(exists groupAnnotation = attributeDeclaration.annotations<OptionGroupAnnotation>().first) {
			value attributeClass = attributeType;

			MappedOptions<>? groupMapper;

			// Handle Null specifically to allow Null-only values (generated by generics in our case)
			if(is Class<Null> attributeClass) {
				groupMapper = null;
			} else {
				"Option groups must be class types, but ``attributeClass`` isn't. Note that union types and null itself are not supported."
				assert(is Class<Object> attributeClass);

				groupMapper = getMappedOptionsFromAnnotations(attributeClass, parserProvider);
			}

			allOptionGroups.add(MappedGroup(attributeDeclaration, groupMapper, groupAnnotation.absorbed));
			continue;
		}

		// Get possible optional value and parser.
		value optionalValueAnnotation = attributeDeclaration.annotations<OptionalValueAnnotation>().first;
		value optionalValue = optionalValueAnnotation exists;
		value optionalValueDefault = optionalValueAnnotation?.default;
		value parser = getParserFromAnnotationUnsafe(attributeDeclaration, attributeType, parserProvider);

		// Options are required if they aren't defaulted, unless we are dealing with list types (ValueParser.multiValue) here.
		// If a list type, we also check ValueParser.forceRequired, used to handle {Element+}.
		// If everything else fails, we can also annotate values using RequiredAnnotation.
		value required = (!attributeDeclaration.defaulted && (!parser.multiValue || parser.forceRequired));

		variable MappedAttribute? mappedField = null;

		// Iterate over the other Annotations (for options and operands)
		value annotations = attributeDeclaration.annotations<OptionAnnotation|OperandAnnotation>();
		assert(nonempty annotations);

		for(value annotation in annotations) {
			if(is OperandAnnotation annotation) {
				if(!mappedField exists) {
					value displayName = attributeDeclaration.annotations<ValueLabelAnnotation>().first?.label else toOptionName(attributeDeclaration.name);
					mappedField = MappedAttribute(displayName, attributeDeclaration, parser, parser.multiValue);
				}

				assert(exists createdField = mappedField);
				value operand = OrderedOperand(createdField, annotation.order, required, parser.multiValue);
				allOperandsList.add(operand);
			} else {
				// If no names were given, create a name based on the attribute's name.
				value names = if(nonempty annotNames = annotation.names) then annotNames else [toOptionName(attributeDeclaration.name)];

				if(!mappedField exists) {
					mappedField = MappedAttribute(names.first, attributeDeclaration, parser, parser.multiValue);
				}

				// Add an option for this name.
				assert(exists createdField = mappedField);
				value optionItem = AvailableOption<MappedAttribute>(createdField, names, required, annotation.readValue, !optionalValue, annotation.presentValue else optionalValueDefault);
				allOptionsList.add(optionItem);
			}
		}

		assert(exists createdField = mappedField);
		allFields.add(createdField);
	}

	// Return a new MappedOptions instance.
	return MappedOptions<Result,SpecialOption>(forClass, allOptionsList.sequence(), allOperandsList.sequence(), allOptionGroups.sequence(), specialOptions);
}